// tslint:disable
import axios, { AxiosRequestConfig, AxiosInstance, AxiosPromise, AxiosResponse, AxiosError, Canceler } from "axios";
// Utils
import { isEmpty } from "@sebgroup/frontend-tools/dist/isEmpty";
import { StorageManagement } from "@sebgroup/frontend-tools/dist/StorageManagement";
{{#interceptorPath}}
import * as interceptor from "{{interceptorPath}}";
{{/interceptorPath}}
{{#configPath}}
// Other
import * as configs from "{{configPath}}";
{{/configPath}}

let mocks: any;
{{#apiInfo}}
{{debugger}}
{{/apiInfo}}
if (process.env.NODE_ENV !== "production") {
    mocks = require("./mocks.json");
}

interface KeyValuePair {
    [key: string]: any;
}

export const defaultBasePath: string = "{{baseUrl}}".replace(/\/$/, "");

export enum StorageKeysEnum {
    TOKEN = "TOKEN"
}

export interface Authentication {
    /** Apply authentication settings to header and query params. */
    applyToRequest(requestOptions: any): void;
}

export interface AxiosResponseInterceptor<T = any> {
    onFullfilled: (response: AxiosResponse<T>) => AxiosResponse<T>;
    onRejected: (err: AxiosError<any>) => Promise<never>;
}

export interface DefaultConfig {
    delay: number;
    defaultHeaders?: () => {};
    useMock?: boolean;
}

export function simulateData(resolve: any, data: any, status: number, timeout: number): any {
    return setTimeout(() => { resolve({ status: status, data: data }); }, timeout);
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: any): void {
        requestOptions.auth = { username: this.username, password: this.password }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) { }

    applyToRequest(requestOptions: AxiosRequestConfig): void {
        if (this.location === "query") {
            requestOptions.params[this.paramName] = this.apiKey;
        } else if (this.location === "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: any): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization2"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: any): void { /** Do nothing */ }
}

{{^configPath}}
const configs: DefaultConfig = {
    delay: 1500,
    defaultHeaders: () => {
        return {};
    },
    useMock: false
}
{{/configPath}}

export class APIHandler {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = configs.defaultHeaders();
    protected authentications: any = [];
    protected axiosInstance: AxiosInstance = axios.create();
    protected storage: StorageManagement = new StorageManagement();
    protected className: string;

    constructor(className: string) {
        this.className = className;
        {{#interceptorPath}}
        this.axiosInstance.interceptors.response.use(interceptor.onFullfilled, interceptor.onRejected);
        {{/interceptorPath}}
    }

    /**
     * Initializes the authentication with the stored TOKEN key if authentication is required
     * @param isAuth Is authentication enabled for this API call
     */
    protected initAuth(isAuth: boolean): void {
        if (isAuth && this.authentications.length) {
            this.authentications[this.authentications.length - 1].apiKey = this.storage.getItem(StorageKeysEnum.TOKEN);
        } else {
            this.axiosInstance.defaults.withCredentials = true;
        }
    }

    /**
     * Initializes the API url with the URL params
     * @param path The API path
     * @param urlParams The url params to be inserted in the API path
     * @returns The initialized API URL
     */
    protected initAPIURL(path: string, urlParams: KeyValuePair): string {
        if (urlParams) {
            for (let key in urlParams) {
                path = path.replace(`{${key}}`, urlParams[key]);
            }
        }
        return this.basePath + path;
    }

    /**
     * Merges two objects by mutating the original with the add-on
     * @param original The original object that will be mutated with the add on object
     * @param addOn The add-on object to be merged with the original
     */
    protected mergeObjects(original: any, addOn: any): void {
        if (!isEmpty(addOn)) {
            for (let key in addOn) {
                if (addOn[key] !== undefined) {
                    original[key] = addOn[key];
                }
            }
        }
    }

    /**
     * Initializes the API call options with query params and header params
     * @param options The HTTP options object to be initialized
     * @param queryParams The query params to be inserted
     * @param headerParams The header params to be inserted
     * @param isAuth Whether to apply token for authentication or not
     * @returns the initialized options object
     */
    protected initOptions(options: AxiosRequestConfig, queryParams: KeyValuePair, headerParams: KeyValuePair, isAuth: boolean, canceler: (c: Canceler) => void): AxiosRequestConfig {
        options = options || {};
        options.headers = !isEmpty(this.defaultHeaders) ? { ...this.defaultHeaders, ...options.headers } : options.headers;
        options.params = options.params ? options.params : {};
        options.responseType = options.responseType ? options.responseType : "json";
        this.mergeObjects(options.params, queryParams);
        this.mergeObjects(options.headers, headerParams);
        (isAuth && this.authentications && this.authentications.length) && this.authentications[this.authentications.length - 1].applyToRequest(options);
        if (canceler) {
            options.cancelToken = new axios.CancelToken((cancel: Canceler) => canceler(cancel))
        }
        return options;
    }

    /**
     * Make an API call
     * @param method The HTTP method (`get`, `delete`, `post`, `put`)
     * @param url The URL of the API to call
     * @param options The http options to be sent
     * @param body The body of the request, if any
     * @param methodName The name of the api method making this call
     */
    protected makeCall<T>(method: string, url: string, options: AxiosRequestConfig, body: any = null, methodName: string): AxiosPromise<T> {
        if (configs.useMock) {
            return new Promise((resolve) => { simulateData(resolve, mocks[this.className][methodName][200] || mocks[this.className][methodName]["default"] || mocks[this.className][methodName], 200, {{#configPath}}{{configName}}{{/configPath}}{{^configPath}}configs{{/configPath}}.delay); });
        } else {
            switch (method) {
                case "get": return this.axiosInstance.get<T>(url, options);
                case "delete": return this.axiosInstance.delete(url, options);
                case "post": return this.axiosInstance.post<T>(url, body, options);
                case "put": return this.axiosInstance.put<T>(url, body, options);
                default: throw new Error(`Invalid HTTP method ${method}`);
            }
        }
    }
}

export type AttributeMapItem = {
    name: string;
    type: string;
};

export type APIParams = {
    canceler?: (c: Canceler) => void;
    options?: AxiosRequestConfig;
};

export type APIModelOptions = {
    [key: string]: any;
    /** The value of properties of type `string` */
    string?: string;
    /** The value of properties of type `number` */
    number?: number;
    /** The value of  properties of type`boolean` */
    boolean?: boolean;
    /** The value  properties of typeof `date` */
    date?: Date;
    /** The value o properties of typef `array` */
    array?: Array<any>;
};

export class APIModel {

    /**
     * Initializes and attribute map item as a primitive type
     * @param item An attribute map item to use as reference
     * @param options The options passed in the constructor to override the default values
     * @returns The value to be initialized with
     */
    static initAsPimitiveType(item: AttributeMapItem, options?: APIModelOptions): any {
        switch (true) {
            case /string/i.test(item.type): return options && options.string !== undefined ? options.string : "";
            case /number/i.test(item.type): return options && options.number !== undefined ? options.number : null;
            case /boolean/i.test(item.type): return options && options.boolean !== undefined ? options.boolean : null;
            case /date/i.test(item.type): return options && options.date !== undefined ? options.date : null;
            case /array/i.test(item.type): return options && options.array !== undefined ? options.array : [];
            default: return null;
        }
    }

    constructor(attributeMap: Array<AttributeMapItem>, options?: APIModelOptions) {
        if (attributeMap && attributeMap.map) {
            attributeMap.map((item: AttributeMapItem) => {
                if (options && options instanceof Object) {
                    const optionName: string = Object.keys(options).find((name: string) => {
                        return item.name.toLowerCase() === name.toLowerCase();
                    });
                    if (optionName) {
                        this[item.name] = options[optionName];
                    } else {
                        this[item.name] = APIModel.initAsPimitiveType(item, options);
                    }
                } else {
                    this[item.name] = APIModel.initAsPimitiveType(item, options);
                }
            });
        }
    }
}
{{#models}}
    {{#model}}
        {{#hasEnums}}
            {{#-first}}

export const enumsMap: {[index: string]: any} = { 
            {{/-first}}
            {{#vars}}
                {{#isEnum}}
                    {{#isContainer}}
    "{{classname}}.{{enumName}}": {{classname}}.{{enumName}}{{^-last}},{{/-last}}
                    {{/isContainer}}
                    {{#isNotContainer}}
    "{{datatypeWithEnum}}": {{datatypeWithEnum}}{{^-last}},{{/-last}}
                    {{/isNotContainer}}
                {{/isEnum}}
            {{/vars}}
            {{#-last}}
};
            {{/-last}}
        {{/hasEnums}}
    {{/model}}
{{/models}}

export namespace APIURLTypes {
    {{#apiInfo}}
    {{#apis}}
    {{#operations}}
    export interface {{classname}} {
        {{#operation}}{{nickname}}: string;{{#hasMore}}
        {{/hasMore}}{{/operation}}
    }
    {{/operations}}
    {{/apis}}
    {{/apiInfo}}
}
